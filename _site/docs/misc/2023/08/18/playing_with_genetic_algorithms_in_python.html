<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Playing with genetic algorithms in python | Josep Rubió Piqué</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Playing with genetic algorithms in python" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Edit: This post made it to the front page of Hacker News! You can find the discussion here." />
<meta property="og:description" content="Edit: This post made it to the front page of Hacker News! You can find the discussion here." />
<link rel="canonical" href="http://localhost:4000/docs/misc/2023/08/18/playing_with_genetic_algorithms_in_python.html" />
<meta property="og:url" content="http://localhost:4000/docs/misc/2023/08/18/playing_with_genetic_algorithms_in_python.html" />
<meta property="og:site_name" content="Josep Rubió Piqué" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-18T18:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Playing with genetic algorithms in python" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-18T18:00:00-06:00","datePublished":"2023-08-18T18:00:00-06:00","description":"Edit: This post made it to the front page of Hacker News! You can find the discussion here.","headline":"Playing with genetic algorithms in python","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/docs/misc/2023/08/18/playing_with_genetic_algorithms_in_python.html"},"url":"http://localhost:4000/docs/misc/2023/08/18/playing_with_genetic_algorithms_in_python.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Josep Rubió Piqué" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Josep Rubió Piqué</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/photos/">Photos</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Playing with genetic algorithms in python</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-08-18T18:00:00-06:00" itemprop="datePublished">Aug 18, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em>Edit: This post made it to the front page of Hacker News! You can find the discussion <a href="https://news.ycombinator.com/item?id=37407802">here</a>.</em></p>

<p>A long long time ago I was young and going to school to attend a Computer Science program. It was so long ago that the data structures course was done in C++ and Java was shown to us as the new kid on the block.</p>

<p>Something I learned in CS that sticked in my head were Genetic Algorithms. I guess the reason was that GA were one of the first (and few) applied things I saw in CS and it seemed to me a simple, intuitive and brilliant idea. Today I was bored at home and I decided to play a little bit with it.</p>

<p><a href="https://en.wikipedia.org/wiki/Genetic_algorithm">GAs</a> are a search technique that is inspired in biological evolution and genetic mutations which are used to purge certain parts of the search space. This is done encoding the nodes in the space into a genetic representation and using a fitness function to evaluate them.</p>

<p>I started implementing a useless but I think illustrative example of GAs which is generating a sequence of random bits and then search for it. Plotting it as an $nxn$ matrix makes it is easier to  visualize and debug the process.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/random_array.png" alt="image" /></p>

<p>This is a 15x15 array, so 225 bits and therefore a space of 2^225 possible combinations. Next I define the fitness function which is nothing more than the amount of bits of the image have the same value. In Numpy it would be:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">matrix1</span><span class="p">,</span> <span class="n">matrix2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">matrix1</span> <span class="o">==</span> <span class="n">matrix2</span><span class="p">).</span><span class="nb">sum</span><span class="p">()</span>
</code></pre></div></div>

<p>The genetic algorithm implementation per se (the fitness function, crossover and mutation) is implemented below, where the parameters <strong>population</strong> is the initial population and <strong>mutations</strong> are the percentage of mutated bits.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">ga</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">mutations</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">matrix1</span><span class="p">,</span> <span class="n">matrix2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">matrix1</span> <span class="o">==</span> <span class="n">matrix2</span><span class="p">).</span><span class="nb">sum</span><span class="p">()</span>

    <span class="n">rows</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="n">rows</span><span class="o">//</span><span class="mi">2</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">population</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">population</span><span class="p">))</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mem</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        
        <span class="c1"># When initialized bottom will contain a set of random individuals. Later it will be
</span>        <span class="c1"># the bottom of the list of individuals sorted by score
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bottom</span><span class="p">:</span>
            <span class="n">scores</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">array</span><span class="p">)</span>

        <span class="c1"># Check if the solution has been found
</span>        <span class="n">max_score</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scores</span><span class="p">[</span><span class="n">max_score</span><span class="p">]</span> <span class="o">==</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">max_score</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray</span><span class="p">)</span>  <span class="c1"># use appropriate colormap here
</span>            <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">break</span>

        <span class="c1"># Select the population of individuals according to the score function
</span>        <span class="n">top_n_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">population</span><span class="p">)</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">top_n_scores</span><span class="p">[</span><span class="n">population</span><span class="p">:]</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">top_n_scores</span><span class="p">[:</span><span class="n">population</span><span class="p">]</span>

        <span class="c1"># Create #population new elements from the crossover and mutation
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
            
            <span class="c1"># Crossover -&gt; Select parents from the top individuals
</span>            <span class="c1">#
</span>            <span class="c1"># I tried this with random.choice or just picking a random position from the list and
</span>            <span class="c1"># the next one. The result is the same for both but way faster
</span>            <span class="c1"># with the latter option.
</span>            <span class="c1"># The reason it still works might be either because of the randomization of the initial 
</span>            <span class="c1"># population or maybe the implementation of argpartition? or both?
</span>            <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">))</span>  
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)]</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">top</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            
            <span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="n">mid</span><span class="p">]</span>
            <span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="o">-</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="o">-</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>

            <span class="c1"># Mutation -&gt; Mutate the bits
</span>            <span class="c1">#
</span>            <span class="c1"># The random choice of the bits to mutate is the most costly of the implementation
</span>            <span class="c1"># It seems there has to be some way to speed up this 
</span>            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="o">-</span><span class="n">mutations</span><span class="p">),</span> <span class="n">mutations</span><span class="p">],</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span><span class="n">columns</span><span class="p">))</span>
            <span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">idx</span><span class="p">)</span>

</code></pre></div></div>
<p>With some manual testing and trial error I ended up with an initial population of 500 and a mutation of 0.5% as the fastest way to find the array of bits, which finishes in approximately 160 iterations and 3 seconds in my computer. Even the experiment not making sense seems pretty good to me taking into account that the space is 2^225 and it can be implemented with few lines of code.</p>

<p>The entire implementation can be found <a href="https://github.com/joseprupi/ga/blob/master/test.ipynb">here</a></p>

<p>Next I wanted to try something more useful, solving mastermind with 6 colors and 4 pegs, the original game had to be solved with 12 moves.</p>

<p>The implementation is similar to the previous one, mostly changing the score function. To count the number of evaluated choices I memoize the score function.</p>

<p>My best approach is a population of 2, and mutate 1 out of 4 pegs, with an average of ~36 evaluateed choices, so three times more than what would be the 12 choices of the original game. Something interesting is that with only crossover and mutation the information regarding the pegs with the correct color but not in the correct spot does not seem to be relevant.</p>

<p>The entire implementation can be found <a href="https://github.com/joseprupi/ga/blob/master/mastermind.ipynb">here</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">ga</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">mutations</span><span class="p">):</span>

    <span class="n">score_memoization</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
        
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">score_memoization</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">score_memoization</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">tmp_board</span> <span class="o">=</span> <span class="n">board</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">in_place</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">in_place_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">same_color</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">choice</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">choice</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">in_place</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">in_place_list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">tmp_board</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">choice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_place_list</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tmp_board</span><span class="p">:</span>
                <span class="n">same_color</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># In correct place and correct color
</span>        <span class="c1">#score = (2 * in_place) + same_color
</span>        
        <span class="c1"># Only in correct place
</span>        <span class="n">score</span> <span class="o">=</span> <span class="n">in_place</span>

        <span class="n">score_memoization</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>

        <span class="k">return</span> <span class="n">score</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="mi">4</span><span class="o">//</span><span class="mi">2</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">population</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">population</span><span class="p">))</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mem</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        
        <span class="c1"># When initialized bottom will contain a set of random individuals. Later it will be
</span>        <span class="c1"># the bottom of the list of individuals sorted by score
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bottom</span><span class="p">:</span>
            <span class="n">scores</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="c1"># Check if the solution has been found
</span>        <span class="n">max_score</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scores</span><span class="p">[</span><span class="n">max_score</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">score_memoization</span><span class="p">)</span>

        <span class="c1"># Select the population of individuals according to the score function
</span>        <span class="n">top_n_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argpartition</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">population</span><span class="p">)</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">top_n_scores</span><span class="p">[</span><span class="n">population</span><span class="p">:]</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">top_n_scores</span><span class="p">[:</span><span class="n">population</span><span class="p">]</span>

        <span class="c1"># Create #population new elements from the crossover and mutation
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>

            <span class="c1"># Crossover -&gt; Select parents from the top individuals
</span>            <span class="c1">#
</span>            <span class="c1"># I tried this with random.choice or just picking a random position from the list and
</span>            <span class="c1"># the next one. The result is the same for both but way faster
</span>            <span class="c1"># with the latter option.
</span>            <span class="c1"># The reason it still works might be either because of the randomization of the initial 
</span>            <span class="c1"># population or maybe the implementation of argpartition? or both?
</span>            
            <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">))</span>  
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)]</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">top</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            
            <span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="n">mid</span><span class="p">]</span>
            <span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="o">-</span><span class="p">(</span><span class="n">mid</span><span class="p">):]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="o">-</span><span class="p">(</span><span class="n">mid</span><span class="p">):]</span>

            <span class="c1"># Mutation -&gt; Mutate the bits
</span>            <span class="c1">#
</span>            <span class="c1"># The random choice of the bits to mutate is the most costly of the implementation
</span>            <span class="c1"># It seems there has to be some way to speed up this 
</span>            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="o">-</span><span class="n">mutations</span><span class="p">),</span> <span class="n">mutations</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mutations</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mutations</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mutations</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mutations</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mutations</span><span class="o">/</span><span class="mi">6</span><span class="p">],</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)):</span>
                <span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">%</span><span class="mi">6</span>
</code></pre></div></div>


  </div><a class="u-url" href="/docs/misc/2023/08/18/playing_with_genetic_algorithms_in_python.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Josep Rubió Piqué</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Josep Rubió Piqué</li><li><a class="u-email" href="mailto:joseprupi@gmail.com">joseprupi@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/joseprupi"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">joseprupi</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my website.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
